# 7. Color Kernels

- ìƒ‰ ì •ë³´ë“¤ì„ ê´€ë¦¬.

## Creating a Threshold Filter
- ğŸ¤§ ë‚˜ì˜ ì •ë¦¬ ğŸ¤§ : threshold FilterëŠ” rgbê°’ì„ ê³„ì‚°ìœ¼ë¡œ ë¹›ì˜ ë‹¨ìœ„ì¸ float ê°’ì¸ lumaë¥¼ ê³„ì‚°í•˜ê³  ê·¸ ê³„ì‚°ê°’ì— ë”°ë¼ ë°ì€ ë¶€ë¶„ì€ í°ìƒ‰ìœ¼ë¡œ ì–´ë‘ìš´ ë¶€ë¶€ì€ ê²€ì€ìƒ‰ì¸ ì´ë¯¸ì§€ë¡œ ë¦¬í„´ëœë‹¤. ë°ì€ ë¶€ë¶„ì„ í‘œì‹œí•  ì •ë„ë¥¼ kCIInputParameter ì¤‘ inputThresholdì—ì„œ ì •ì˜í•´ì¤€ë‹¤. 

#### Calculating Threshold, ê¸°ì¤€ì¹˜ ê³„ì‚°í•˜ê¸°
- RGB colorì—ì„œ ë°ê¸°ë¥¼ ê³„ì‚°í•˜ëŠ” ë°©ë²•ì„ ì‚¬ìš©í•œë‹¤. `luma = (red * 0.2126)+(green * 0.7152)+(blue * 0.0722)`
- greenì€ ë°ìŒìœ¼ë¡œ blueëŠ” ì–´ë‘ì›€ìœ¼ë¡œ ì¸ì‹í•œë‹¤.

#### The Kernel Code
- Color Kernelì´ ë•Œì— ì ë‹¹í•œ í”½ì…€ì— í•„ìš”í•œ ê²ƒê³¼ ì–´ë– í•œ ì£¼ë³€í”½ì…€ì˜ ê°’ì„ ì‹ ê²½ì“°ì§€ì•Šê¸° ì‹œì‘í•œ í›„ë¶€í„°, CIColorKernelì„ ìƒˆë¡œ ì°½ì‘í•˜ëŠ” ì´ í•„í„°ì— ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
- ì´ë¯¸ì§€ì— ì‘ìš©í•˜ëŠ” ëŒ€ì‹ ì— Color kernelì€ ì ì–´ë„ í•˜ë‚˜, í•˜ë‚˜ì˜ í”½ì…€ì˜ ìƒ‰ì„ ê°–ê³  ìˆëŠ” `__sample` íƒ€ì…ì˜ argumentê°€ í•„ìš”í•˜ë‹¤. ê·¸ë¦¬ê³  ê¸°ì¤€ì¹˜ ê°’ì¸ `threshold`ë¼ê³  ë¶€ë¥´ëŠ”  `float(ìˆ«ì)`ì—ì„œ ì§€ë‚˜ê°ˆ ê²ƒì´ë‹¤.

	`kernel vec4 thresholdFilter(__sample pixel, float threshold)`
- í•¨ìˆ˜ ì•ˆìª½ì—ì„œ, pixelì˜ ìƒ‰ ê°’ì— ê¸°ë°˜ì„ ë‘”  `luma`ë¥¼ ë§Œë“œëŠ”ë° ê³µì‹ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. `sample` typeì€ `vec4-`ì™€ ë¹„ìŠ·í•˜ë‹¤. ê°ê°ì˜ x, y, z, wì˜ color componentsì— ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤. í•˜ì§€ë§Œ ìƒ‰ì— ì œê³µëœ í›„ë¶€í„° r,g,b,aì™€ red, blue, greenì— ì ‘ê·¼í•˜ëŠ” ê²ƒì€ ë” ëª…ë°±í•´ ì¡Œë‹¤.

	`float luma = (pixel.r * 0.2126) + (pixel.g * 0.7152) + (pixel.b * 0.0722); `
	
- ìœ„ì˜ ê³„ì‚°ì€ ë‘ ë²¡í„°ì˜ doc productë¥¼ ë°˜í™˜í•˜ëŠ” `dot()` í•¨ìˆ˜ê°€ ì‚¬ìš©ë˜ì—ˆë‹¤. dot productëŠ” ê°ê°ì˜ í•˜ë‚˜ì˜ ë²¡í„°ì—ì„œ ë‘ë²ˆì§¸ ë²¡í„°ì˜ ê°™ì€ ìœ„ì¹˜ì˜ ì•„ì´í…œìœ¼ë¡œë¶€í„° ì¦ê°€ëœ ì•„ì´í…œì˜ í•©ì´ë‹¤.
- ë§Œì•½ 3ê°œì˜ ìƒ‰ì—ì„œ ë¹› ê°’ì˜ ë‘ë²ˆì§¸ ë²¡í„°ë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤ë©´, `dot()`ì„ ì‚¬ìš©í•˜ë©´ returnì€ ì•„ë˜ì™€ ê°™ë‹¤.

	`float luma = dot(pixel.rgb, vec3(0.2126, 0.7152, 0.0722));`
	
- ì´ ê²½ìš°ì—ì„œ, alphaê°’ì€ ê´€ê³„í•˜ê³  ìˆì§€ ì•Šë‹¤. ê·¸ë˜ì„œ 3ê°œì˜ component vectorì¸ `vec3` orginal pixel colorì¸ red, green, blueë¡œ ë¶€í„° ë§Œë“¤ì—ˆë‹¤.
- ì•„ë˜ì˜ ë§ˆì§€ë§‰ í•¨ìˆ˜ ì½”ë“œ í•œ ì¤„ì€ ë°›ì•„ì˜¨ ê°’ì˜ ë¦¬í„´ì„ whiteë¡œ í• ì§€ blackìœ¼ë¡œ í• ì§€ ê²°ì •í•˜ëŠ”ë° ì‚¬ìš©í•œë‹¤.

	`return (luma>threshold) ? vec(1.0, 1.0, 1.0, 1.0) : vec4(0.0, 0.0, 0.0, 0.0);`

#### Eliminating Branching with step(), `step()`ìœ¼ë¡œ Branchingì„ ì œê±°í•˜ê¸°.
- (luma > threshold)ì˜ ê³¼ì •ì´ 3ì°¨ì›ì¼ì§€ë¼ë„, kernel codeì˜ í¼í¬ë¨¼ìŠ¤ë¥¼ ì¶©ëŒ ì‹œí‚¬ ìˆ˜ ìˆëŠ” `branching`ì„ ì†Œê°œí•œë‹¤.
- GPSëŠ” ë³‘ë ¬(ë™ì‹œì˜ ìˆ˜í–‰í•˜ëŠ” ì˜ë¯¸)ì—ì„œ ë‹¤ì–‘í•œ kernelë“¤ì„ ì‹¤í–‰í•˜ì§€ë§Œ, `wavefront`ì™€ ê°™ì€ ê²ƒìœ¼ë¡œ í•¨ê»˜ ì ê²¨ì ¸ ìˆë‹¤. 
- ë‹¤ë¥¸ branchë“¤ì—ì„œ ì‚¬ìš©ë˜ëŠ” ë‹¤ì–‘í•œ kernelë“¤ì„ ê°€ì§€ë©´ì„œ, ì˜ˆë¥¼ ë“¤ì–´ `ifë¬¸`ì€ wavefrontê°€ ì™„ì„±ë˜ê¸° ì „ ëª¨ë“  ë³‘ë ¬ì˜ kernelì€ ë‘ê°œì˜ brance ëª¨ë‘ ì‹¤í–‰ë˜ëŠ” ê²ƒì„ ê¸°ë‹¤ë¦¬ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤. ??????????
- ì´ê²ƒì„ ë³‘ë ¬ì‹œ ì¬ë² ì¹˜ ë˜ëŠ”ê²ƒìœ¼ë¡œë¶€í„° `step()` í•¨ìˆ˜ë¡œ ê·¹ë³µí•  ìˆ˜ ìˆë‹¤.
- `step()`ì€ ë‘ê°œì˜ argumentë¥¼ ë°›ì•„ë“¤ì¸ë‹¤. í•˜ë‚˜ëŠ” edge, ë‹¤ë¥¸ í•˜ë‚˜ëŠ” edgeì— ë°˜ëŒ€ë¡œ ë¹„êµë˜ëŠ” ê°’ì´ë‹¤. ê°’(value)ì´ edgeë³´ë‹¤ ì‘ë‹¤ë©´ `step()`ì€ 0ìœ¼ë¡œ ë°˜í™˜ë˜ê³ , edgeë³´ë‹¤ ê°’ì´ í¬ë©´ `step()`ì€ 1ì„ ë°˜í™˜í•œë‹¤. í•„í„°ì˜ ì´ë¯¸ì§€ í”½ì…€ ë¦¬í„´ì´ blackì¸ì§€ whiteì¸ì§€ ë‚˜íƒ€ë‚´ëŠ” `vec4`ì„ êµ¬ì„±í•˜ëŠ” ê°’ì„ ë¦¬í„´í•˜ëŠ” ê²ƒì— ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

	`return vec4(step(threshold, luma));`
	
- vec4ëŠ” single floatê³¼ í•¨ê»˜ êµ¬ì„± ë  ìˆ˜ ìˆë‹¤. In this case that value populates all four of its components.


#### Wrapping in a Core Image Filter
- custom filterë¥¼ ìˆ˜í–‰í•˜ëŠ”ë°ì— `CIFilter`ë¥¼ í™•ì¥í•  ìˆ˜ ìˆê³ , custom threshold filterë¥¼ ë§Œë“œëŠ”ë°ì— ë¹„ìŠ·í•œ ì ‘ê·¼ì„ ì‚¬ìš©í•  ê²ƒì´ë‹¤.
- ğŸ˜€ ì²« ë²ˆì§¸ ë‹¨ê³„, `ThresholdFilter` ì´ë¦„ì˜ `CIFilter`ë¥¼ ìƒì†ë°›ëŠ” ìƒˆë¡œìš´ classë¥¼ ë§Œë“¤ê¸°. `inputImage`, `inputThresohld` 2ê°œì˜ propertyë¥¼ ë§Œë“ ë‹¤.

	```swift
	class ThresholdFilter: CIFilter :
	
		var inputImage:CIImage?
		var inputThreshold:CGFloat = 0.75
		
		//ğŸ˜€ kernelë§Œë“¤ê¸°, CIColorKernelì„ ë§Œë“¤ê³  GLSL ì½”ë“œë¡œ ì‘ì„±í•œë‹¤.
		let thresholdKernel = CIColorKernel(string:
													"kernel vec4 thresholdFilter(__sample pixel, float threshold)" +
													{ " +
													"	float luma = (pixel.r * 0.2126) + " +
													"		(pixel.g*0.7152) + " +
													"		(pixel.b*0.0722); " +
													"	return vec4(step(threshold, luma)); " +
													"}				"
											) 
	
		//ë¶ˆí–‰íˆë„ ì´ string ë¬¸ì¥ í›„ì—, runtimeê¹Œì§€ ì½”ë“œì— ì–´ë–¤ ë¬¸ì œê°€ ìˆë‹¤ë©´ ì•Œê²Œ ë  ê²ƒì´ë‹¤.
		//filterì˜ outputImageê°€ ì˜ë¬¸ì„ í’ˆê²Œ ë  ë•Œ, kernelì„ ì ìš©í•  ê²ƒì´ë‹¤. CIColorKernelì˜ ê²½ìš°ì—ëŠ” ê°„ë‹¨í•˜ê²Œ ë˜ì§€ ì•Šì•˜ì—ˆë‹¤.											//ì²« ë²ˆì§¸ ë‹¨ê³„ëŠ” ë‘ê°œì˜ optional propertyê°€ ê°’ì„ ê°€ì§€ëŠ” ê²ƒì„ í™•ì‹¤í•˜ê²Œ í•˜ëŠ”ë°ì— guard ë¬¸ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ë‹¤.
		//kernelì„ ì»´íŒŒì¼í•˜ê³  CIImage ê·¸ë¦¬ëŠ” í•¨ìˆ˜ëŠ” ğŸ’¡ `applyWithExtent`ì´ë‹¤.	
			// > ì˜ˆ) í•„í„°ì— ì „ì²´ ì´ë¯¸ì§€ì— ì ìš©í•˜ê¸°.
			//		first argumentì™€ ê°™ì€ input imageì˜ í¬ê¸°ì™€ 2ê°œì˜ kernel function parameterë¥¼ ê°–ê³  ìˆëŠ” arrayë¥¼ ì§€ë‚˜ê°„ë‹¤.
		
		override var outputImage : CIImage! {
		
			guard let inputImage = inputImage, thresholdKernel = thresholdKernel else {
			
				return nil
				
			}
			
			let extent = inputImage.extent 
			let argument = [inputImage, inputThreshold]
			
			return thresholdKernel.applyWithExtent(extent, arguments: arguments)
		
		}
		
		
		//ìƒˆë¡œìš´ threshold filterëŠ” ì‚¬ìš©ë  ìˆ˜ ìˆë‹¤. ğŸ˜€ í•„í„° ë“±ë¡í•˜ê¸°.
		CIFilter.registerFilterName("ThresholdFilter", constructor: CustomFiltersVendor(), classAttributes: [kCIAttributeFilterCategories: [CategoryCustomFilters]])
		
		case "ThresholdFilter": return ThresholdFilter()
		
		//ğŸ˜€ ì‚¬ìš©í•˜ëŠ” ë°©ë²• 1. ë‹¤ë¥¸ í•„í„°ì²˜ëŸ¼ ë„ì§‘ì–´ë‚´ì„œ ì‚¬ìš©í•˜ê¸°.
		let thresholdFilter = CIFilter(name: "ThresholdFilter", withInputParameters: [kCIInputImageKey: image, "inputThreshold": 0.8])
		
		//ğŸ˜€ ì‚¬ìš©í•˜ëŠ” ë°©ë²• 2. propertyë¡œ ì ‘ê·¼í•´ì„œ ì‚¬ìš©í•˜ê¸°.
		let thresholdFilter = ThresholdFilter()
		thresholdFilter.inputImage = image
		thresholdFilter.inputThresholdFilter()
		
	}
	```

#### Creating a Starburst Filter
- threshold filterëŠ” ë§ì€ ì‚¬ìš©ì´ ë˜ì§€ ì•Šì„ ìˆ˜ ìˆë‹¤. í•˜ì§€ë§Œ ë‹¤ë¥¸ í•„í„°ì™€ ê²°í•©í•˜ë©´, ë¹›ì— ë”°ë¥¸ íš¨ê³¼ë¥¼ ì„ íƒì ìœ¼ë¡œ ì ìš©í•˜ê²Œ ë˜ë¯€ë¡œ ìœ ìš©í•´ì§„ë‹¤.

	- ì˜ˆ. ë°±ì—´ê´‘ì€ ì´ë¯¸ì§€ì˜ ê°€ì¥ ë°ì€ ì˜ì—­ìœ¼ë¡œ ê³¨ë¼ë‚´ê³  í‚¤ë¼í‚¤ë¼ì™€ ê°™ì€ íš¨ê³¼ë¥¼ ì£¼ê¸°.
		
		```swift
			let candlesImage = CIImage(image: UIImage(named: "candles.jpg")!)!
			let thresholdImage = candlesImage.imageByApplyingFilter("ThresholdFilter", withInputParameters: ["inputThreshold": 0.9])
			
			//2ê°œì˜ motion blur ì ìš©í•˜ê¸°. í•˜ë‚˜ëŠ” 45ë„, í•˜ë‚˜ëŠ” 135ë„.
			let blurImageOne = thresholdImage.imageByApplyingFilter("CIMotionBlur", withInputParameters: [kCIInputRadiusKey: 30, kCIInputAngleKey: M_PI_4]).imageByCroppingToRect(candlesImage.extent)
			let cropRect = candlesImage.extent
			let blurImageTwo = thresholdImage.imageByApplyingFilter("CIMotionBlur", withInputParameters: [kCIInputRadiusKey: 30, kCIInputAngleKey: M_PI_4 + M_PI_2]).imageByCroppingToRect(candleImage.extent)
			
			//2ê°œì˜ ì ìš©ëœ ì´ë¯¸ì§€ë“¤ì„ í•©ì¹˜ë©´ ë¹›ë‚˜ëŠ” ê²ƒì²˜ëŸ¼ íš¨ê³¼ê°€ ëœë‹¤.
			let starBurstImage = blurImageOne.imageByApplyingFilter("CIAdditionCompositing", withInputParameters: [kCIInputBackgroundImageKey: blurImageTwo])
			
			//ì›ë³¸ ì´ë¯¸ì§€ì— ë°˜ì§ë°˜ì§í•œ ê²ƒì„ í•©ì¹œë‹¤.
			let finalCompositeImage = candlesImage.imageByApplyingFilter("CIAdditionCompositing", withInputParameters: [kCIInputBackgroundImageKey: starBurstImage])
		```
		
		- ìœ„ì™€ ê°™ì€ íš¨ê³¼ë„ ë‹¤ë¥¸ ì½”ë“œë¡œ êµ¬í˜„.
		
		```swift
			let starBurstAccumulator = CIImageAccumulator(extent: thresholdImage.extent, format: kCIformatARGB8)
			
			for i in 0..< inputBeamCount {
			
				let angle = CGFloat((M_PI/Double(inputBeamCount))*Double(i))
				
				let starburst = thresholdImage.imageByApplyingFilter("CIMotionBlur", withInputParameters: [kCIInputRadiusKey: inputRadius, kCIInputAngleKey: inputAngle + angle]).imageByCroppingToRect(thresholdImage.extent).imageByApplyingFilter("CIAdditionCompositing", withInputParameters: [kCIInputBackgroundImageKey: starBurstAccumulator.image()])
				
				starBurstAccumulator.setImage(starburst)
			
			}
		```

## Shaded Tile Effect
#### Technique
- `tileSize` argumentë¥¼ ë°›ì•„ë“¤ì´ê³ , ì´ê²ƒì„ modulo operatorì— ë¡œê·¸ ê³„ìˆ˜ì²˜ëŸ¼ ì‚¬ìš©í•œë‹¤.
- ê²°ê³¼ëŠ” tile sizeì— ë”°ë¼ ë‚˜ë‰˜ì–´ê³  ì œê±°ëœë‹¤.

`let brightnessMultiplier = 1.0 - (x % tileSize) / tileSize`

#### The Kernel Code
- our shadrì—ì„œ GLSL codeëŠ” x, y ì¢Œí‘œì˜ ë¹›ì— ê¸°ì´ˆë¥¼ ë‘” moduloë¥¼ ê³„ì‚°í•  ìˆ˜ ìˆë‹¤.
- current pixelì˜ ì¢Œí‘œë¥¼ ì–»ê¸° ìœ„í•´ì„œëŠ”, x, yê°’ì´ ìˆëŠ” `vec2`ë¥¼ returní•˜ëŠ” `samplerCoord()` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•  ê²ƒì´ë‹¤.

	```swift
	kernel vec4 thresholdFilter(__sample pixel, float tileSize){
		vec2 coord = samplerCoord(pixel);
		float brightness = mod(coord.y, tileSize)/tileSize;
		brightness *= 1.0 - mod(coord.x, tileSize)/tileSize;
		return vec4(brightness*(pixel.rgb), image.a);
	}
	```	
	- ğŸ’¡ GLSLì€ %(ë‚˜ë¨¸ì§€)ë¥¼ ì§€ì›í•˜ì§€ ì•Šê¸°ë•Œë¬¸ì— `mod()`í•¨ìˆ˜ë¥¼ ì‚¬ìš©í–ˆë‹¤.

#### Wrapping in a Core Image Filter

```swift
class ShadedTileFilter: CIFilter {

	var inputImage: CIImage?
	var inputTileSize: CGFloat = 100
	
	override func setDefaults(){
		inputTileSize = 100
	}
	
	var kernel = CIColorKernel(string:
										"kernel vec4 thresholdFilter(__sample pixel, float tileSize)" +
										"{" +
										"	vec2 coord = samplerCoord(pixel); " +
										"	float brightness = mod(coord.y, tileSize)/tileSize; " +
										"	brightness *= 1.0 _ mod(coord.x, tileSize)/tileSize; " +
										"	return vec4(brightness * (pixel), image.a);"
										"}"
								)
	//outputImage getterë¥¼ overrideí•˜ëŠ” ê²ƒ. kernelì€ input image, input tile size ìš”êµ¬í•œë‹¤. ê·¸ë˜ì„œ ìš”êµ¬í•˜ëŠ” ê²ƒë“¤ì„ arrayì— ë„£ì–´ì¤€ë‹¹
	
	override var outputImage: CIImage! {
	
		guard let inputImage = inputImage, kernel = kernel else {
			return nil
		}
		
		let extent = inputImage.extent
		let arguments = [inputImage, inputTileSize]
		
		return kernel.applyingExtent(extent, argumetns: arguments)
	
	}

}
```


## CRT Shadow Mask Filter
- ğŸ¤§ ë‚˜ì˜ ì •ë¦¬ ğŸ¤§ :
- ì–´ë– í•œ ë‹¤ë¥¸ í”½ì…€ì˜ ì§€ì‹ ì—†ì´ current pixelì˜ ìƒ‰ì„ ì¡°ì‘í•˜ëŠ” ê²ƒì´ ë””ìì¸ë˜ì—ˆë‹¤.
- color kernelì˜ ëŒ€í‘œì ì¸ ì‘ì—…ì€ color imageë¥¼ ë‹¨ìƒ‰í™”(monochrome)í™” í•˜ê±°ë‚˜ ì´ë¯¸ì§€ì˜ ë°ê¸°ë‚˜ ëŒ€ì¡°ë¥¼ ë³€ê²½ë  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì´ë‹¤.

#### CRT Screen Filter

#### The Kernel Code
- `CIColorKernel`ì´ `__sample` íƒ€ì…ì˜ single pixelì„ ì§€ë‚˜ì¹  ë•Œ, Recallëœë‹¤.
- argumentì—ì„œ í˜•ê´‘ì²´ì˜ width(=`phosphorWidth`)ì™€ scan lineì˜ height(= `scanlineHeight`)ê°€ ì •ì˜ëœ kernel codeë¡œ ì§€ë‚˜ê°€ê¸¸ ì›í•œë‹¤. kernelì´ 4ê°€ì§€ sizeì˜ vectorì„ ë¦¬í„´ì‹œí‚¨ í›„, ì½”ë“œì˜ ì²«ì¤„ì€ ì•„ë˜ì™€ ê°™ë‹¤.

	```swift
	kernel vec4 crtColor(__sample pixel,
		float phosphorWidth,
		float scanlineHeight) {
	```
	
- kernelì˜ ì²«ë²ˆì§¸ ì¼ì€ 0 ~ 2 ë²”ìœ„ì—ì„œ coloringì— ì‚¬ìš©ë  column indexë¥¼ ê³„ì‚°í•˜ëŠ” ê²ƒì´ë‹¤. ê³„ì‚°ëœ ê°’ìœ¼ë¡œ pixelì˜ ê°€ë¡œë¡œ ê°€ë¡œ ì¢Œí‘œë¥¼ ë‚˜ëˆ„ëŠ” ê²ƒê³¼ 3ì˜ modulusì™€ modulo operatorë¥¼ ì ìš©í•˜ëŠ” ê²ƒ, ë‘ ê°€ì§€ë¥¼ í•  ìˆ˜ ìˆë‹¤.

	```swift
	int columnIndex = int(
	
		mod(samplerCoord(pixel).x / phosphorWidth, 3.0)
	
	);
	```
- scan lineì„ coloringí•˜ëŠ”ë° ì‚¬ìš©ë  row indexë¥¼ ê³„ì‚°í•˜ëŠ” ë°ì— ë¹„ìŠ·í•œ ìˆœì„œë¡œ ì‚¬ìš©í•œë‹¤. í•˜ì§€ë§Œ ì´ë•Œ `pixelHeight`ì˜ modulusë¥¼ ì‚¬ìš©í•¨. ????????????????

	```swift
	int rowIndex = int(
		mod(samplerCoord(pixel).y, scanlineHeight)
	);
	```

- row indexì™€ í•¨ê»˜, ì²« ë²ˆì§¸ì˜ ë‘ê°œì˜ ì¤„ì˜ ëª¨ë“  `pixelHeight`ë¥¼ í¬ë¯¸í•˜ê²Œ í•  ë‹¤ë¥¸ ë³€ìˆ˜(=`scanlineMultipler`)ë¥¼ ë§Œë“œëŠ”ë°ì— 3ê°œë¡œ ì´ë£¨ì–´ì§„ operatorë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. ???????????

	```swift
	float  scanlineMultiplier = (rowIndex == 0 || rowIndex == 1)?
		0.3:
		1.0;
	```
p. 142 ğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸ
[link](https://github.com/FlexMonkey/Filterpedia/blob/master/Filterpedia/customFilters/CRTFilter.swift)

#### Wrapping in a Core Image Filter

## Simulating VHS Tracing Lines
- ì´ í•„í„°ëŠ” time basedì´ê³ , input time parameterë¥¼ ë…¸ì¶œì‹œí‚¨ë‹¤.

#### Creating an Animated Noise Field
- Core Imageì˜ noise imageë¥¼ ë°œìƒì‹œí‚¤ëŠ” `CIRandomGenerator`ë¥¼ ì‚¬ìš©í•œë‹¤. 
- ì‹œê°„ì´ ì§€ë‚¨ì— ë”°ë¼ noiseê°€ ë³€í™”í•˜ê¸¸ ì›í•˜ëŠ”ë° `CIRandomGenerator`ëŠ” í•­ìƒ ê°™ì€ outputìœ¼ë¡œ ë°˜í™˜ëœë‹¤. ê·¸ë¦¬ê³  ê°€ë¡œ ì¤„ì´ ìˆëŠ” ê±¸ ì›í•œë‹¤.
- ì‹œê°„ì— ë”°ë¼ ë³€í™”í•˜ëŠ” noise ì˜ì—­ ë§Œë“¤ê¸°! ê°„ë‹¨í•˜ê²Œ random positionìœ¼ë¡œ ì›€ì§ì¼ ìˆ˜ ìˆë‹¤. random ë°œìƒ ì˜ì—­ì´ í•œì—†ì´ í° ì´ë¯¸ì§€ì— ë§Œë“¤ì–´ì§„ í›„ì—, source image ìœ„ì—ì„œ íš¨ê³¼ì ìœ¼ë¡œ ì›€ì§ì„ì„ ë³€í™”ì‹œí‚¤ë©´ ëœë‹¤.

```swift
	//ğŸ˜€ `tx`ë¼ëŠ” random x, yë¥¼ constantë¥¼ ë§Œë“ ë‹¤. 
	let tx = NSValue(CGAffineTransform: CGAffineTransformMakeTranslation(CGFloat(drand48()*100), CGFloat(drand48()*100)))
	
	//ğŸ˜€ ì§€ì§€ì§ê±°ë¦¼ì€ `CILanczosScaleTransform` í•„í„°ì˜ aspect ratio 5ë¡œ ì ìš©ëœë‹¤.
	// random generator, affine transform, Lanczos scaleì€ ì•„ë˜ì˜ ì½”ë“œë¡œ ì ìš©ëœë‹¤.
	let noise = CIFilter(name: "CIRandomGenerator")!.outputImage!.imageByApplyingFilter("CIAffineTransform", withInputParameters: [kCIInputTransformKey: tx]).imageByApplyingFilter("CILanszosScaleTrnasform", withInputParameters: [kCIInputAspectRatioKey: 5]).imageByCroppingToRect(inputImage.extent)
```

#### Creating the Tracking Lines Kernel, ê°€ë¡œì¤„ í•„í„° ë§Œë“¤ê¸°
- í•„í„°ì˜ input imageì˜ ì†ì—, kernelì„ í†µí•´ì„œ ë§Œë“  noise imageê°€ ì§€ë‚˜ê°ˆ ê²ƒì´ë‹¤.
- ë˜í•œ kernelì€ ì¤„ë¬´ëŠ¬ noiseë¥¼ animatedí•˜ëŠ”ë°ì— time parameterê°€ í•„ìš”í•˜ê³ , stripeì˜ widthì™€ spacingì„ controlí•  ì¶”ê°€ì ì¸ parameterë¥¼ ì œê³µí•  ê²ƒì´ë‹¤.
- ì•„ë˜ì˜ ì½”ë“œëŠ” `vhsTrackingLines`ì˜ í•¨ìˆ˜ë¥¼ ì„ ì–¸í•œ ê²ƒì´ë‹¤.

	```swift
	kernel vec4 vhsTrackingLines(__sample image, __sample noise, float time, float spacing, float stripeHeight, float backgroundNoise)
	```	
	
- stripeì˜ ìœ„ì¹˜ëŠ” ê³„ì‚°ëœ pixelì˜ ì„¸ë¡œ ìœ„ì¹˜ì— ì˜ì¡´í•œë‹¤. kernel functionì˜ ì²«ë²ˆì§¸ ë‹¨ê³„ëŠ” yì˜ ìœ„ì¹˜ ë³€ìˆ˜ë¥¼ ì •í•˜ëŠ” ê²ƒì´ë‹¤.

	`float y = samplerCoord(image).y;`

- current timeì— ì¶”ê°€ëœ yì˜ ì‚¬ì¸(ì‚¬ì¸, ì½”ì‚¬ì¸, íƒ„ì  íŠ¸ ì¤‘ì˜ ì‚¬ì¸!)ì„ ê°€ì§ˆ ê²ƒì´ë‹¤. spacingë„ ë‚˜ëˆŒ ê²ƒì´ë‹¤.
- barì˜ ë‘ê»˜ë¥¼ controlí•˜ëŠ” ê²ƒ. `smoothstep()` function ì†ì˜ ê°’ì„ ì§€ë‚˜ê°ˆ ê²ƒì´ë‹¤. `smoothstep()`ì€ ë‚˜ì¤‘ì— ë’¤ì—ì„œ ìì„¸í•˜ê²Œ ì„¤ëª…í•œë‹¤!

	```swift
	float stripe = smoothstep(1.0 - stripeHeight, 1.0, sin((time+y)/spacing));
	```
- stripe noise valueë¥¼ ì¶”ê°€í•œë‹¤.

	```swift
	return image+(noise*noise*stripe)+(noise*backgroundNoise);
	```

#### Wrapping in Core Image Filter
- .

```swift
	//ğŸ˜€ overrideëœ `outputImage` getterëŠ” ë‹¤ì–‘í•œ valueë“¤ì´ ìˆëŠ” kernelì„ ì§€ë‚˜ê°€ëŠ”ê²ƒì´ í•„ìš”í•˜ë‹¤.
	let argument = [inputImage, noise, inputTime, inputSpacing, inputStripeHeight, inputBackgroundNoise]
	
	//ğŸ˜€ ì „ì²´ ì´ë¯¸ì§€ì— í•„í„°ë¥¼ ì ìš©í•˜ê¸°. `applyWithExtent`ë¥¼ ì‚¬ìš©í•˜ê¸°.
	let final = kernel.applyWithExtent(inputImage.extent, arguments: arguments)?.imageByApplyingFilter("CIPhotoEffectNoir", withInputParameters:nil)
```

## Pseudocolor with Mix & Smoothstep
#### Introduction
- pseudocolor filterì˜ ê¸°ë³¸ì²˜ëŸ¼ ì‘ë™í•  kernelì„ ë§Œë“œëŠ” ìƒ‰ ì‚¬ì´ë¥¼ ì‚½ì…í•˜ëŠ”ë°ì— ë‘ê°€ì§€ techiniqueë¥¼ ì‚´í´ë³¸ë‹¤.
- pseudocolor imageëŠ” ìì‹ ì˜ sourceì™€ output imageì— ê¸°ì´ˆë¥¼ ë‘” map colorì™€ ê°™ì€ monochrome(ë‹¨ìƒ‰) imageë¥¼ ê°€ì§„ë‹¤.
- ëŒ€í‘œì ì¸ ì‚¬ìš©ìœ¼ë¡œëŠ” monochrome elevation map ë˜ëŠ” ì ì™¸ì„  ì¹´ë©”ë¼ì˜ í‘ë°±ì‚¬ì§„ê°™ì€ outputì„ colorlize ì‹œí‚¤ëŠ” ê²ƒì´ë‹¤.
- inputColor0.... inputColor4ì™€ ê°™ì€ 5ê°€ì§€ ìƒ‰ì„ ë§Œë“¤ê³  inputColor0ì€ input imageì˜ ê°€ì¥ ì–´ë‘ìš´ ì˜ì—­ìœ¼ë¡œ inputColor4ëŠ” ê°€ì¥ ë°ì€ ì˜ì—­ìœ¼ë¡œ mapping ì‹œí‚¨ë‹¤.
	- Color 0 : Blue(0, 0, 1)
	- Color 1 : Yellow(1, 1, 0)
	- Color 2 : Black(0, 0, 0)
	- Color 3 : Green(0, 1, 0)
	- Color 4 : Red(1, 0, 0)

#### Linear Interpolation
- .

	```swift
	kernel vec4 pseudoColor(__sample pixel,
			vec4 inputColor0,
			vec4 inputColor1,
			vec4 inputColor2,
			vec4 inputColor3,
			vec4 inputColor4)
			
			
	//ë°ê¸°ì— ë”°ë¼ì„œ ìƒ‰ì„ ë³€í•˜ê²Œ í•˜ê¸°.
	vec4 luma = vec4(doc(pixel.rgb, vec3(0.2126, 0.7152, 0.0722)));
	
	// mix() í•¨ìˆ˜ëŠ” 3ê°œì˜ argumentë¥¼ ê°€ì§„ë‹¤. ë‘ê°€ì§€ëŠ” ì²˜ìŒê³¼ ëì˜ ë²”ìœ„ë¥¼ ì§€ì •í•˜ê³ , ë‚˜ë¨¸ì§€ í•˜ë‚˜ëŠ” ì •ìƒí™” ê°’ì´ë‹¤.
	if luma.x < 0.25 {
		
		//0~0.25 ë²”ìœ„ì— 4ë¥¼ ê³±í•´ì£¼ì—ˆìœ¼ë¯€ë¡œ 0~1ì˜ ë²”ìœ„ë¡œ ëŠ˜ì–´ë‚œë‹¤.
		return mix(inputColor0, inputColor1, luma*4.0);
	}
	
	if luma.x >=0.25 && luma.x<0.5 {
		return mix(inputColor1, inputColor2, (luma-0.25)*4.0);
	}
	
	if luma.x >= 0.5 && luma.x < 0.75 {
		return mix(inputColor2, inputColor3, (luma-0.5)*4.0);
	}
	
	return mix(inputColor3, inputColor4, (luma-0.75)*4.0);
	
	```

#### Hermite Interpolation
- GLSL functionë“¤ì¸ `mix()`ì™€ `smoothstep()`ì˜ ì°¨ì´ì  : ì²«ë²ˆì§¸ì™€ ë‘ë²ˆì§¸ argumentëŠ” edge of the interpolation, ì„¸ë²ˆì§¸ argumentëŠ” interpolateí•˜ëŠ” valueë¼ëŠ” ê²ƒì´ë‹¤.

#### Mixing Between Linear and Hermite

## Filtering Indivisual Channels
#### Introduction
- .

```swift
	kernel vec4 rgbChannelCompositing(__sample red, __sample green, __sample blue) {
		return vec4(red.r, green.g, blue.b, 1.0);
	}
	
	
	let seaside = CIImage(image: UIImage(named: "seaside.jpg")!)!
	
	let redImage = seaside.imageByAppyingFilter("CIColorControls", withInputParameters:[kCIInputContrastKey: 2.8])
	
	let greenImage = seaside.imagByApplyingFilter("CIColorControls", withInputParameters: [kCIInputContrastKey: 2.25, kCIInputBrightnessKey: 0.25])
	
	let blueImage = seaside.imageByApplyingFilteR("CIColorControls", withInputParameters:[kCIInputBrightnessKey: -0.25])
	
	let rgbCompositing = CIFilter(name : "RGBChannelCompositing", wittInputParameters: ["inputRedImage":redImage, "inputGreenImage": greenImage, "inputBlueImage":blueImage])
```

[GitHub ê¼­ ì½ì–´ë³´ê¸°!ğŸ’¡](https://github.com/FlexMonkey/Filterpedia/blob/master/Filterpedia/customFilters/RGBChannelCompositing.swift)

#### RGB Brightness and Contrast Filter
- r, g, bê°’ì— ê°ê° ì´ë¯¸ì§€ ë„£ì–´ì„œ í•©ì³ ì£¼ëŠ” ë°©ì‹.

```swift
class RGBChannelBrightnessAndContrast: CIFilter {
	var inputImage: CIImage?
	
	var inputRedBrightness: CGFloat = 0
	var inputRedContrast: CGFloat = 1
	
	var inputGreenBrightness: CGFloat = 0
	var inputGreenContrast: CGFloat = 1
	
	var inputBlueBrightness: CGFloat = 0
	var inputBlueContrast: CGFloat = 1
	
	override var outputImage: CIImage! {
		
		guard let inputImage = inputImage else{
			return nil
		}
		
		let red = inputImage.imageByApplyingFilter("CIColorControls", withInputParameters: [kCIInputBrightnessKey: inputRedBrightness, kCIInputContrastKey: inputRedContrast])
		
		let green = inputImage.imageByApplyingFilter("CIColorControls", withInputParameters:[kCIInputBrightnessKey: iputGreenBrightness, kCIInputContrastKey: inputGreenContrast])
		
		let blue = inputImage.imageByApplyingFilter("CIColorControls", withInputParameters:[kCIInputBrightnessKey: inputBlueBrightness, kCIInputContrastKey: inputBlueContrast])
		
		rgbChannelCompositing.inputRedImage = red
		rgbChannelCompositing.inputGreenImage = green
		rgbChannelCompositing.inputBlueImage = blue
		
		let finalImage = rgbChannelCompositing.outputImage
		
		return finalImage
	}

}
```

- í•œ ë²ˆì— ê°ê° argument ì§€ì •í•´ì£¼ëŠ” ë°©ì‹

	```swift
		let treatedSeaside = seaside.imageByApplyingFilter("RGBChannelBrightnessAndContrast", withInputParameters: ["inputRedContrast": 2.8, "inptGreenContrast": 2.25, "inputGreenBrightness": 0.25, "inputBlueBrightness": 0.-25])
	```

#### RGB Tone Curve Filter
- í¬í† ìƒµì—ì„œ ì²˜ëŸ¼ r, g, b ê°ê°ì˜ ê·¸ë˜í”„ë¥¼ ì¡°ì •í•˜ì—¬ ê° ê°’ì˜ ëª…ë„ì™€ ëŒ€ë¹„ë¥¼ ì¡°ì •.
- `CIToneCurve` :  r, g, bê°’ ìƒê´€ì—†ì´ input image ìì²´ì˜ ê³¡ì„  ê·¸ë˜í”„ë¥¼ ì¡°ì •.
- `RGBChannelBrightnessAndContrast` & `CIToneCurve` : ë¶„ë¦¬ëœ tone curveë¥¼ ê°ê°ì˜ color channelë¡œ.

	```swift
	var inputRedValue = CIVector(values:[0.0, 0.25, 0.5, 0.75, 1.0], count:5)
	var inputGreenValue = CIVector(values:[0.0, 0.25, 0.5, 0.75, 1.0], count:5)
	var inputBlueValue = CIVector(values: [0.0, 0.25, 0.5, 0.75, 1.0], count:5)
	
	let red = inputImageByApplyingFilter("CIToneCurve", withInputParameters: [
																				"inputPoint0" : CIVector(x:0.0, y: inputRedValues.valueAtIndex(0)), 
																				"inputPoint1" : CIVector(x:0.25, y: inputRedValues.valueAtIndex(1)), 
																				"inputPoint2" : CIVector(x:0.5, y:inputRedValues.valueAtIndex(2)),
																				"inputPoint3" : CIVector(x:0.75, y:inputRedValues.valueAtIndex(3)),
																				"inputPoint4" : CIVector(x: 1.0, y: inputRedValues.valueAtIndex(4))
	])
	
	let blue = ....
	let green = ....
	
	let rgbChannelCompositing = RGBChannelCompositing()
	rgbChannelCompositing.inputRedImage = red
	rgbChannelCompositing.inputBlueImage = blue
	rgbChannelCompositing.inputGreenImage = green
	
	return rgbChannelCompositing.outputImage
	```

#### RGB Gaussian Blur
- green channelë§Œ blur.

	```swift
	var inputRedRadius: CGFloat = 2
	var inputGreenRadius: CGFloat = 4
	var inputBlueRadius: CGFloat = 8
	
	override var outputImage: CGImage! {
	
		guard let inputImage = inputImage else {
			return nil
		}
		
		let red = inputImage.imageByApplyingFilter("CIGaussianBlur", withInputParameters: [kCIInputRadiusKey: inputRedRadius]).imageByClampingToExtent()
		let green = inputImage.imageByApplyingFilter("CIGaussianBlur", withInputParameters: [kCIInputRadiusKey: inputGreenRadius]).imageByClampingToExtent()
		let blue = inputImage.imageByApplyingFilter("CIGaussianBlur", withInputParameters: [kCIInputRadiusKey: inputBlueRadius]).imageByClampingToExtent()
		
		let rgbChannelCompositing = RGBChannelCompositing()
		
		rgbChannelCompositing.inputRedImage = red
		rgbChannelCompoisiting.inputGreenImage = green
		rgbChannelCompositing.inputBlurImage = blue
		
		return rgbChannelCompositing.outputImage
		
	}
	
	```

#### Chromatic Aberration
- .

```swift
var inputAngle: CGFloat = 0
var inputRadius: CGFloat = 2

override var outputImage:CGImage! {
	
	//touëŠ” 2íŒŒì´ë¡œ ì •ì˜ëœë‹¤.
	let redAngle = inputAngle + tou
	let greenAngle = inputAngle + tou*0.333
	let blueAngle = inputAngle + tou*0.666
	
	
	let redTransform = CGAffineTransformMakeTranslation(
		sin(redAngle) * inputRadius,
		cos(redAngle) * inputRadius)
		
	let greenTransform = CGAffineTransformMakeTranslation(
		sin(greenAngle) * inputRadius,
		cos(greenAngle) * inputRadius)
		
	let blueTransform = CGAffineTransformMakeTranslation(
		sin(blueAngle) * inputRadius,
		cos(blueAngle) * inputRadius)
		
		
	let red = inputImage.imageByApplyingFilter("CIAffineTransform, withInputParameters: [kCIInputParameters: [kCIInputTransformKey: NSValue(CGAffineTransform: redTransform)]).imageByCroppingToRect(inputImage.extent)
	let green = inputImage.imageByApplyingFilter("CIAffineTransform, withInputParameters: [kCIInputParameters: [kCIInputTransformKey: NSValue(CGAFffineTransform: greenTransform)]).imageByCroppingToRect(inputImage.extent)
	let blue = inputImage.imageByApplyingFilter("CIAffineTransform, withInputParameters: [kCIInputParameters: [kCIInputTrnasformKey: NSValue(CGAffineTransform: bluTransform)]).imageByCroppingToRect(inputImage.extent)
	
	let rgbChannelCompositing = RGBChannelCompositing()
	
	rgbChannelCompositing.inputRedImage = red
	rgbChannelCompositing.inputGreenImage = green
	rgbChannelCompositing.inputBlueImage = blue
	
	return finalImage = rgbChannelCompositing.outputImage
}
```

## Color Map Filter Revisited
#### Creating an Eight Bit Filter
- .

```swift
    static let appleIIColors = [
        RGB(r: 0, g: 0, b: 0),
        RGB(r: 114, g: 38, b: 64),
        RGB(r: 64, g: 51, b: 127),
        RGB(r: 228, g: 52, b: 254),
        RGB(r: 14, g: 89, b: 64),
        RGB(r: 128, g: 128, b: 128),
        RGB(r: 27, g: 154, b: 254),
        RGB(r: 191, g: 179, b: 255),
        RGB(r: 64, g: 76, b: 0),
        RGB(r: 228, g: 101, b: 1),
        RGB(r: 128, g: 128, b: 128),
        RGB(r: 241, g: 166, b: 191),
        RGB(r: 27, g: 203, b: 1),
        RGB(r: 191, g: 204, b: 128),
        RGB(r: 141, g: 217, b: 191),
        RGB(r: 255, g: 255, b: 255)
    ]
    
    override var outputImage:CGImage? {
    	let paletteIndex = max(min(EightBit.palettes.count-1, Int(inputPaletteIndex)), 0)
    	let palette = EightBit.palettes[paletteIndex]
    	
    	//color kernel! every color's every pixelì˜ ê±°ë¦¬ë¥¼ ì˜ë¯¸.
    	
        var kernelString = "kernel vec4 thresholdFilter(__sample image)"
        	kernelString += "{ \n"
        	kernelString += "   vec2 uv = samplerCoord(image); \n"
        	kernelString += "   float dist = distance(image.rgb, \(palette.first!.toVectorString())); \n"
        	kernelString += "   vec3 returnColor = \(palette.first!.toVectorString());\n "
        	
        kernel vec4 thresholdFilter(__sample image){
        	vec2 uv = samplerCoord(image);
        	float dist = distance(image.rgb, vec3(0.0, 0.0, 0.0)));
        	vec3 returnColor = vec3(0.0, 0.0, 0.0);
        }
        	
        for paletteColor in palette where paletteColor != palette.first!
        {
            kernelString += "if (distance(image.rgb, \(paletteColor.toVectorString())) < dist) \n"
            kernelString += "{ \n"
            kernelString += "   dist = distance(image.rgb, \(paletteColor.toVectorString())); \n"
            kernelString += "   returnColor = \(paletteColor.toVectorString()); \n"
            kernelString += "} \n"
        }        	
        
        if distance(image.rgb, vec3(0.44, 0.14, 0.25)) < dist {
        	dist = distance(image.rgb, vec3(0.44, 0.14, 0.25));
        	returnColor = vec3(0.44, 0.14, 0.25);
        }
        
        if distance(image.rgb, vec3(0.25, 0.2, 0.49)) < dist {
        	dist = distance(image.rgb, vec3(0.25, 0.2, 0.49));
        	returnColor = vec3(0.25, 0.2, 0.49);
        }
        
        let extent = inputImage.extent
        let pixellatedImage = inputImage.imageByApplyingFilter("CIPixellate", withInputParameters: [kCIInputScaleKey: inputScale])
        
        let final = kernel.applyWithExtent(extent, arguments: [pixellatedImage])
        
        return final
    }
    
```

[github code](https://github.com/FlexMonkey/Filterpedia/blob/master/Filterpedia/customFilters/EightBit.swift)

## Setting Extent for Color Kernels
#### Single Image Color Kernels
- .

```swift
//RedGreenFilter
kernel vec4 thresholdFilter(__sample image) {
	return vec4(image.r, image.g*0.5, 0.0, image.a);
}

//BlueGreenFilter
kernel vec4 thresholdFilter(__sample image){
	return vec4(0.0, image.g*0.5, image.b, image.a);
}

override var outputImage :CIImage! {
	guard let inputImage = inputImage, kernel = kernel else{
		return nil
	}
	
	let extent = self.extent ?? inputImage.extent
	
	let argument = [inputImage]
	
	return kernel.applyWithExtent(extent, arguments: arguments)
}

let blueGreenFilter= BlueGreenFilter()
bluegreenFilter.inputImage = sunflower
bluegreenFilter.extent = sunflower.extent.insetBy(dx:0, dy:200)
let blueGreenOutput = bluegreenFilter.outputImage

```

#### Composite Image Color Kernels, í•©ì„±ì‚¬ì§„ color kernel