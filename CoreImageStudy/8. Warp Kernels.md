# 8. Warp Kernels
- ê¸°í•˜í•™ì ìœ¼ë¡œ ì´ë¯¸ì§€ë¥¼ ë°”ê¿€ ë•Œ ì‚¬ìš©í•œë‹¤. ì‰½ê²Œ íšŒì „ì‹œí‚¤ê±°ë‚˜ ë Œì¦ˆì— íš¨ê³¼ë¥¼ ì¤„ ìˆ˜ ìˆë‹¤.

## Barrel Distortion Filter, ì–´ì•ˆë Œì¦ˆê°™ì€ ì™œê³¡ì˜ í•„í„°.
#### Introduction
> ğŸ’¡ë‚˜ì˜ ì •ë¦¬ğŸ’¡ : warpkernelì„ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œëŠ” GLSL functionì¸ `destCoord()`ë¥¼ ì´ìš©í•´ì„œ 2ì°¨ì›ì¸ x, y ì¢Œí‘œë¡œ ì´ë£¨ì–´ì§„ vec2ë¥¼ ë³€í˜•í•œ vec2 valueë¥¼ ìµœì¢… ë¦¬í„´ìœ¼ë¡œ ì‚¬ìš©í•˜ì—¬ filterë¥¼ ë§Œë“¤ì–´ ì‚¬ìš©í•œë‹¤.

- `CIWarpKernel`ì— ê¸°ì´ˆë¥¼ ë‘”ë‹¤. warp kernelì€ `destCoord()`ì— ì ‘ê·¼í•œë‹¤.
	```swift
	return vec2(destCoord().x, (height-1.0)-destCoord().y);
	```
- warp kernelì€ ìƒ‰ì— ì „í˜€ ê´€ë ¨ì´ ì—†ë‹¤.

#### The Kernel Code
- .

```swift
//vec2ë¡œ ì •ì˜í–ˆìœ¼ë¯€ë¡œ 2ì°¨ì›ì¸ ì´ë¯¸ì§€ì˜ width, heightì— ì ‘ê·¼ì´ ê°€ëŠ¥í•˜ë‹¤.
kernel vec2 crtWarp(vec2 extent)

//ìš°ë¦¬ì˜ ì´ë¯¸ì§€ëŠ” 900*300 ì‚¬ì´ì¦ˆ. -1ì—ì„œ +1ë¡œ x, y ìœ„ì¹˜ë¥¼ ì˜®ê¸¸ ê±°ë‹¤.
//(0,0) > (-1,-1), (450, 150) > (0, 0), (900, 300) > (+1, +1)
vec2 coord = ((destCoord()/extent)-0.5)*2.0;

//ë‹¹ê²¨ì˜¤ê¸°
coord.x *= 1.0 + pow((abs(coord.y)/3.2), 2.0);
coord.y *= 1.0 + pow((abs(coord.x)/3.2), 2.0);

//-1 ~ +1 ë²”ìœ„ì˜ ì¢Œí‘œë“¤ì€ input imageì˜ ì›ë˜ì˜ ìˆë˜ ì¢Œí‘œë¡œ ëŒì•„ê°€ ë‹¤ì‹œ mapë˜ì–´ì•¼ í•œë‹¤.
coord = ((coord/2.0)+0.5)*extent;
return coord;
```

#### Wrapping in a Core Image Filter
- .

```swift
	let crtWarpKernel = CIWarpKernel(string: "...GLSL code...")
	
	//ë¯¸ë¦¬ input sizeë¥¼ ì•Œì•„ì•¼ í•œë‹¤. ë§Œì•½ ì•Œ ë°©ë²•ì´ ì—†ìœ¼ë©´ kernelë‚´ë¶€ì—ì„œ CIVectorë¥¼ ë§Œë“¤ì–´ì„œ ì‚¬ìš©í•œë‹¤.
	//extent ? ì‚¬ê°í˜•ìœ¼ë¡œ working space ì¢Œí‘œì—ì„œ ì´ë¯¸ì§€ì˜ ë²”ìœ„ë¥¼ ì„¤ëª…í•œë‹¤.
	
	override var outputImage:CIImage? {
		
		if let inputImage = inputImage,
				crtWarpKernel = crtWarpKernel {
				
												let arguments = [CIVector(x: inputImage.extent.size.width,
																		y: inputImage.extent.size.height)]
												
												let extent = inputImage.extent
												
												return roiCallback.applyWithExtent(extent, roiCallback: {
														(index, rect) in
														return rect
														},
														
														inputImage: inputImage, arguments:arguments)
		
		}
		
		return nil
	
	}
```
[GitHub Code Link](https://github.com/FlexMonkey/CoreImageCathodeRayTube)

## Carnival Mirror Kernel
- GLSLì˜ `trigonometric`functionì„ ë¬¼ê²°ì²˜ëŸ¼ ì¼ë ì´ê²Œ ì ìš©í•œë‹¤.

#### Carnival Mirral Effect Kernel
- 1) ì„¸ë¡œë¬¼ê²° :  kernelì€ current pixelì˜ y ì¢Œí‘œë¥¼ ê°€ì§€ê³  ê°’ì— ë§ëŠ” sine ê°’ì„ ì¶”ê°€í•œë‹¤. y ê°’ì€ sine functionì„ ì§€ë‚˜ë©´ì„œ ë¬¼ê²° ì„ ìœ¼ë¡œ ë‚˜ë‰˜ì–´ì§„ë‹¤. x ì¢Œí‘œëŠ” ë³€í•˜ì§€ ì•Šì€ì±„ë¡œ ë‚¨ëŠ”ë‹¤.

	```swift
	//parameterì¸ yWavelengthì™€ yAmountì— ë”°ë¼ ì¼ë ì´ëŠ” ë‘ê»˜ì™€ ì •ë„ê°€ ë³€í™”í•œë‹¤.
	
	kernel vec2 carnivalMirror(float yWavelength, float yAmount){
		float y=destCoord().y + sin(destCoord().y / yWavelength) * yAmount
		float x=destCoord().x;
		return vec2(x, y)
	}
	```
- 2) ê°€ë¡œë¬¼ê²° : y ì¢Œí‘œëŠ” ë³€í•˜ì§€ ì•Šì€ì±„ë¡œ ë‚¨ëŠ”ë‹¤. ìœ„ì˜ ì½”ë“œì—ì„œ yì˜ ì½”ë“œë¥¼ xì™€ ë°”ê¾¸ì–´ ì ìš©í•´ì£¼ë©´ ëœë‹¤.

	```swift	
	kernel vec2 carnivalMirror(float xWavelength, float xAmount){
		float y=destCoord().y; 
		float x=destCoord().x + sin(destCoord().x / xWavelength) * xAmount
		return vec2(x, y)
	}
	```
- 3) ê°€ë¡œì„¸ë¡œ ë¬¼ê²° ë‘˜ë‹¤ ì ìš©.

	```swift	
	kernel vec2 carnivalMirror(float xWavelength, float xAmount, float yWavelength, float yAmount){
		float y=destCoord().y + sin(destCoord().y / yWavelength) * yAmount
		float x=destCoord().x + sin(destCoord().x / xWavelength) * xAmount
		return vec2(x, y)
	}
	```	
	
[GitHub Code Link](https://github.com/FlexMonkey/Filterpedia/blob/master/Filterpedia/customFilters/CarnivalMirror.swift)

#### Wrapping in a Core Image Filter
```swift
class CarnivalMirror:CIFilter {

	var inputImage: CIImage?
	
	var inputHorizontalWaveLength: CGFloat = 10
	var inputHorizontalAmount: CGFloat = 20
	
	var inputVerticalWaveLength: CGFloat = 10
	var inputVerticalAmount: CGFloat = 20
	
	let carnivalMirrorKernel = CIWarpKernel(string: "...")
	
	override var outputImage: CIImage! {
		
		if let inputImage = inputImage, kernel = carnivalMirrorKernel {
			
			let arguments = [inputhorizontalWaveLength, inputHorizontalAmount, inputVerticalWaveLength, inputVerticalAmount]
			let extent = inputImage.extent
			
			return kernel.applyWithExtent(extent, roiCallback: { index, rect) in return rect }, inputImage: inputImage, arguments: arguments0
			
		}
		
		return nil
	
	}

}
```

## Region of Interest Callbacks
`applyWithExtent(_:roiCallbCK:inputImage:argumnets:)`

- í° ì´ë¯¸ì§€ë¥¼ í•„í„°ë§ í•˜ê±°ë‚˜ input, outputì˜ ì‚¬ì´ì¦ˆê°€ ë‹¤ë¥´ê±°ë‚˜ ê³ í™”ì§ˆì„ ì›í•  ë•ŒëŠ” ì‚¬ìš©í•´ì„œ return ì‹œì¼œì•¼ í•œë‹¤.

#### A horizontal Scale Filter
- kernelì€ `inputScaleX` parameterë¥¼ ì‚¬ìš©í•˜ê³ , current pixelì˜ x positionì„ ouput ì¢Œí‘œë¥¼ ìƒì„±í•˜ëŠ” valueì— ë§ì¶° ë‚˜ëˆˆë‹¤.

	```swift
	kernel vec2 stretchKernel(float inputScaleX){
		float y = destCoord().y;
		float x = (destCoord().x / inputScaleX);
		
		return vec2(x, y);
	}
	
	override var outputImage: CIImage! {
		if let inputImage=inputImage, kernel = stretchKernel {
			let arguments = [inputScaleX]
			
			let extent = CGRect(origin : inputImage.extent.origin, size: CGSize(width: inputImage.extent.widht * inputScaleX, height: inputImage.extent.height))
			
			return kernel.applyWithExtent(extent, roiCallback: {(index, rect) in return rect}, inputImage: inputImage, arguments: arguments) 
			

		}
		
		return nil
	}
	```