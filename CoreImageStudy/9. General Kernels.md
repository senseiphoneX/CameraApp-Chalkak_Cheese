# 9. General Kernels
## Simple Box Blur
- convolution filterëŠ” blur, sharpen, edge detection, current pixel, surround pixelë“¤ì„ í¬í•¨í•œë‹¤.

#### Box Blur Mechanics
- box blur kernelì€ `image`, `sampler` ë‘ ê°€ì§€ argumentë¥¼ ìˆ˜ìš©í•œë‹¤.

	```swift
	kernel vec4 boxBlur(sampler image, float blurRadius){
		vec2 d = destCoord();
		
		int radius = int(blourRadius);
		float n = 0.0;
		
		vec3 accumulator = vec3(0.0, 0.0, 0.0);
		
		for (int x = -radius; x <= radius; x++) {
			for (int y = -radius; x <= radius; x++) {
				vec2 workingSpaceCoordinate = d+vec2(x,y)
				vec2 imageSpaceCoordinate = samplerTransform(image, workingSpaceCoordinate);
				vec3 color = sampler(image, imageSpaceCoordinate),rgb;
				accumulator += color;
				n += 1.0;
			}
		}
		
		accumulator /= n;
		return vec4(accumulator, 1.0);
	}
	```
	

#### Box Blur Region of Interest
- general kernelì´ ì ìš©ë  ë•Œ, warp kernelê°™ì€ ê²ƒì€ `roiCallback`ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤. í•˜ì§€ë§Œ ìœ„ì—ì„œëŠ” image `extent`ì˜ ë°”ê¹¥ìª½ìœ¼ë¡œ ì‹œí—˜í–ˆë‹¤. ì•„ë˜ë¶€í„´ ì´ìœ ì— ë§ê²Œ ì ì ˆí•˜ê²Œ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ ì‹œí—˜í•´ë³¼ ê²ƒì´ë‹¤.
	- problem case 
		
		```swift
			override var outputImage:CIImage!{
				if let inputImage = inputImage, kernel=kernel {
					let arguments = [inputimage, inputBlurRadius]
					let extent = inputImage.extent
					
					return kernel.applyWitnExtent(extent,roiCallback: roiCallback(), arguments: arguments)
				}
				
				return nil
			
			}
			
			func roiCallback() -> CIKernelROICallback {
				return { (index, rect) in return rect }
			}
		```
			
		- í…Œë‘ë¦¬ì— strokeë¥¼ ì ìš©í•œ ìƒíƒœì—ì„œ ìœ„ì˜ ì½”ë“œì˜ blurë¥¼ ì‹¤í–‰í•˜ë©´ strokeê°€ image ì•ˆìª½ìœ¼ë¡œ ë²ˆì§€ëŠ” ë¬¸ì œê°€ ë°œìƒí•œë‹¤.
		- `roiCallback`ìœ¼ë¡œ returnë˜ëŠ” `rect`ë¥¼ ëŠ˜ë¦°ë‹¤ë©´, í•´ê²°í•  ìˆ˜ ìˆë‹¤.

	- no problem case
		
		```swift
			override func roiCallback() -> CIKernelROICallback {
				
				return { (index, rect) in
					return rect.insetBy(
							dx: -self.inputBlurRadius,
							dy: -self.inputBlurRadius
						)}
			}
		```

#### Wrapping in a Core Image Filter
- warp, color kernelì²˜ëŸ¼, general kernelì€ CIKernel constructorì— passëœ GLSL stringìœ¼ë¡œë¶€í„° ë§Œë“¤ì–´ì§„ë‹¤.

	```swift
	class BoxBlurFilterOne: CIFilter{
	
		var inputImage:CIImage?
		var inputBlurRadius = CGFloat(10)
		var kernel = CIKernel(string: "....")
	
	}
	```

## Luminance Based Variable Blur
#### Introduction
- color kernelì²˜ëŸ¼, general kernelì€ í•˜ë‚˜ì´ìƒì˜ input imageë¥¼ ë°›ì•„ë“¤ì¼ ìˆ˜ ìˆë‹¤. (warp kernelì€ ì•ˆë¨.)

#### Source Images
- ë°ê¸°ë¥¼ ì ìš©í•  blur íš¨ê³¼ì‹œì— ì¶”ê°€í•  source ì´ë¯¸ì§€ ë§Œë“¤ê¸°.

	```swift
		let gradientImage = CIFilter(name: "CIRadialGradient", 
					withInputParameters:[
							kCIInputCenterKey: CIVector(x:320, y:320),
							"inputRadius0":150,
							"inputRadius1":300,
							"inputColor0":CIColor(red:0, green:0, blue:0)
							"inputColor1":CIColor(red:1, grren:1, blue:1)
					])?
					.outputImage?
					.imageByCroppingToRect(CGRect:(x:0, y:0, width:640, height: 640))
	```


#### Variable Blur Mechanics
- variable blur filterì˜ kernelì€ box blurì™€ ë§¤ìš° ë‹¤ë¥´ì§€ ì•Šë‹¤. ìœ„ì—ì„œ ë§Œë“  source image ì†ì„ í†µê³¼í•  `sampler` typeì˜ `blurImage`ë¼ëŠ” argumentê°€ í•˜ë‚˜ ë” ìˆë‹¤.

	```swift
	kernel vec4 redGreenBulge(sampler image, sampler blurImage, float blurRadius) {
		vec2 d = destCoord();
		vec3 blurPixel = sample(blurImage, samplerCoord(blurImage)).rgb;
						+ float blurAmout = dot(blurPixel, vec3(0.2126, 0.7152, 0.0722));
		int radius = int(blurAmount * blurRadius);
		float n = 0.0;
		vec3 accumulator = vec3(0.0, 0.0, 0.0);
		
		for (int x = -radius; x <= radius; x++) {
			for (int y = -radius; y <= radius; y++) {
				vec2 workingSpaceCoordinate = d + vec(x,y);
				vec2 imageSpaceCoordinate = samplerTrnasform(image, workingSpaceCoordinate);
				vec3 color = sample(image, imageSpaceCoordinate),rgb;
				accumulator += color;
				
				n += 1.0;
			}
		}
		
		accumulator /= n;
		return vec4(accumulator, 1.0);
	}
	```

#### Wrapping in a Core Image Filter
- input imageì™€ source gradient imageì˜ aspect ratioê°€ ë‹¤ë¥´ë‹¤.
- ë‹¤ì–‘í•œ blur filterì˜ êµ¬í˜„ì€ blur sourceë¥¼ ëŠ˜ë¦¬ê³ , input imageì˜ ë¹„ìœ¨ì„ ë§ì¶”ëŠ” affine transformìœ¼ë¡œ ë§Œë“¤ì–´ì§„ë‹¤.
	> ğŸ’¡ê°„ë‹¨í•˜ê²Œ ë§í•˜ë©´ blurì˜ source ì´ë¯¸ì§€ë¥¼ input imageì˜ ë¹„ìœ¨ì— ë§ê²Œ ì°Œê·¸ëŸ¬ëœ¨ë¦°ë‹¤.ğŸ’¡

	```swift
		override var inputImage:CIImage!{
			if let inputImage = inputImage, inputBlurImage = inputBlurImage, kernel = kernel {
				let scaledInputBlurImage = inputBlurImage.imageByApplyingTransform(CGAffineTrnasformMakeScale(
																					inputImage.extent.width/inputBlurImage.extent.width,
																					inputImage.extent.height/inputBlurImage.extent.height))
																					
			let arguments = [inputImage, scaledInputBlurImage, inputBlurRadius]
			let extent = inputImage.extent
			
			return kernel.applyWithExtent(extent, roiCallback: {
					(index, rect) in
							if index == 0 {
								return rect.insetBy(dx:self.inputBlurRdius, dy, -self.inputBlurRadius)
							} else {
								return scaledInputBlurImage.extent
							}
			},
				arguments: arguments)
				
			}
			
		
		}
	```

## Kuwahara Filter
#### Introduction
- Kuwahara FilterëŠ” blurí•  ìˆ˜ ìˆì§€ë§Œ imageì˜ edge detailì€ ì‚´ë¦´ ìˆ˜ ìˆëŠ” smoothing filterì´ë‹¤. í˜ì¸íŠ¸ì¹  íš¨ê³¼ì™€ ë¹„ìŠ·í•˜ë‹¹.
- ê°ê°ì˜ pixelì€ ì£¼ë³€ pixelì˜ ì •ë³´ë¥¼ í•„ìš”ë¡œ í•˜ê³  sample areaëŠ” íš¨ê³¼ì ì¸ ê²°ê³¼ë¥¼ í¬ê²Œ(í¼ì ¸ì„œ) ì–»ì„ ìˆ˜ ìˆë‹¤.
- ì£¼ë³€ pixelì˜ ë¹›ì˜ í‰ê· ê°’ê³¼ pixel colorì˜ í‰ê· ì„ ê³„ì‚°í•˜ê³  current pixelì˜ ìƒ‰ì´ returnëœë‹¤.
- argumetnì˜ `pixel` valueì˜ ì¡°ì •ì— ë”°ë¼ í•„í„°ê°€ ì ìš©ë˜ëŠ” ì •ë„ë¥¼ ì¡°ì ˆí•  ìˆ˜ ìˆë‹¤.

#### GLSL for Kuwahara FILTER
- Kuwahara filterì˜ êµ¬í˜„ì€ í•œì •í•  ìˆ˜ ìˆëŠ” ê°ë„ì— ë”°ë¼ ì ìš©ëœë‹¤.
- ì´ í•„í„°ê°€ ë” ë§ŒëŠ¥ì˜ í•„í„°ë¡œ ë§Œë“¤ì–´ ì§ˆì§€ë¼ë„, íš¨ê³¼ë¥¼ ì¤„ ì£¼ë³€ì˜ pixelì˜ referenceì— for-loofë¥¼ ë§Œë“œëŠ”ê²Œ í•„ìš”í•˜ë‹¤. 
- ì´ì›ƒì— ìˆëŠ” pixelê³¼ current pixelì˜ color upate ëª¨ë‘ ì˜ì‹¬í•´ì•¼í•˜ê¸° ë•Œë¬¸ì—, Kuwahara kernelì€ general purpose kernelì¸ `CIKernel`ì´ë‹¤. `CIKernel`ì´ ë˜ë©´, kernel functionì€ `image`ë¡œ ì´ë¦„ì§€ì–´ì§„ sampler typeì˜ argumentì™€ ê°™ì€ imageì˜ ì „ì²´ë¥¼ ì§€ë‚˜ê°€ê²Œ ëœë‹¤. `r`ë¡œ ì´ë¦„ì§€ì–´ì§„ radiusë„ ì§€ë‚˜ê°„ë‹¤.

	```swift
		kernel vec4 kuwahara(sampler image, float r) {
			
			//current pixelì˜ ì¢Œí‘œì™€ ê° ì‚¬ë¶„ë©´ì˜ pixelì˜ ìˆ˜ë¥¼ ê°–ê³  ìˆì„ ë³€ìˆ˜ë¥¼ ë§Œë“¤ì–´ì¤€ë‹¤.
			vec2 d = destCoord();
			int radius = int(r);
			float n = float((radius + 1)*(radius + 1));
			
			//í‰ê·  ê³„ì‚°ê³¼ ì‚¬ìš©í•  valueë¥¼ ê°–ê³  ìˆì„ ê²ƒì´ë‹¤.
			//ê° arrayì˜ first elementëŠ” quadrant `a`, quadrant `b`ë¥¼ ê°–ê³  ìˆë‹¤. 
		
		}
	```
.....

#### Kuwahara Results
.......